plugins {
    id 'com.android.library' version '8.13.0' apply false
    id 'com.android.application' version '8.13.0' apply false
    id 'de.undercouch.download' version '5.6.0' apply false
    id 'signing'
}

import groovy.json.JsonSlurper

static def getSqliteYear(version) {
    def url = 'https://www.sqlite.org/changes.html'
    def text = new URL(url).text
    // Simple regex to match line starting with version
    def matcher = text =~ /(\d{4})-\d{2}-\d{2}\s+\(${version.replaceAll(".", "\\.")}\)/
    if (matcher.find()) {
        return matcher.group(1)
    }
    throw new GradleException("Cannot find release year for SQLite version $version")
}

static def sqliteVersionToCode(version) {
    def parts = version.tokenize('.').collect { it.toInteger() }
    def major = parts[0]
    def minor = parts[1]
    def patch = parts[2]
    return String.format("%d%02d%02d00", major, minor, patch)
}

static def sqliteAmalgamationUrl(version) {
    def code = sqliteVersionToCode(version)
    def year = getSqliteYear(version)
    return "https://sqlite.org/${year}/sqlite-amalgamation-${code}.zip"
}

allprojects {
    afterEvaluate {
        tasks.configureEach { task ->
            if (rootProject.ext.sqliteVersion != "") {
                if (task.name != "downloadSqliteCustom") {
                    def hasDependency = task.dependsOn.any { dep ->
                        if (dep instanceof String) {
                            return dep == "downloadSqlite" || dep == ":sqlite-android:downloadSqlite"
                        } else if (dep instanceof Task) {
                            return dep.name == "downloadSqlite"
                        } else if (dep instanceof TaskProvider) {
                            return dep.name == "downloadSqlite"
                        }
                        return false
                    }
                    if (hasDependency) {
                        task.dependsOn.add(":sqlite-android:downloadSqliteCustom")
                    }
                }
            }
        }
    }
}

project(':sqlite-android') {
    // Force :requery-root to be ready first
    evaluationDependsOn(':requery-root')

    def versionName
    def publishType = -1
    def sqliteVersion
    rootProject.ext.sqliteVersion = ""
    if (rootProject.hasProperty("PUBLISH_TYPE")) {
        if (!(rootProject.getProperty("PUBLISH_TYPE") =~ ~/^Release|Snapshot$/)) {
            throw new GradleException("PUBLISH_TYPE has to be either Release or Snapshot")
        }
        publishType = rootProject.getProperty("PUBLISH_TYPE") == "Release"? 1: 0;
    }
    if (rootProject.hasProperty("VERSION_NAME")) {
        versionName = rootProject.getProperty("VERSION_NAME")
    } else if (project(':requery-root').hasProperty("VERSION_NAME")) {
        versionName = project(':requery-root').getProperty("VERSION_NAME")
        if (publishType == -1) {
            publishType = 0
        }
    } else {
        throw new GradleException("VERSION_NAME not defined neither in root nor requery level")
    }
    def match = versionName =~ ~/^(([0-9]+)\.([0-9]+)\.([0-9]+))(-SNAPSHOT)?$/;
    if (match.find()) {
        sqliteVersion = match[0][1]
        if (rootProject.hasProperty("VERSION_NAME")) {
            rootProject.ext.sqliteVersion = sqliteVersion
        }
        if (publishType == -1) {
            publishType = match[0][5] == null || match[0][5].length() == 0? 1: 0
        }
    } else {
        throw new GradleException("Invalid value for VERSION_NAME: '$versionName'. It must respresent SQLite version with optional -SNAPSHOT suffix")
    }
    if (publishType == 0) {
        if (!versionName.toUpperCase().endsWith('-SNAPSHOT')) {
            versionName += '-SNAPSHOT'
        }
    } else if (publishType == 1) {
        versionName = versionName.replaceAll(/-SNAPSHOT$/, '')
    }

    project.ext.set("sqliteDistributionUrl", "fdfsdfs")
    project.ext.set("VERSION_NAME", versionName)

    if (project.hasProperty("POM_ARTIFACT_ID")) {
        project.ext.set("POM_ARTIFACT_ID", rootProject.getProperty("POM_ARTIFACT_ID"))
    }
    if (project.hasProperty("POM_NAME")) {
        project.ext.set("POM_NAME", rootProject.getProperty("POM_NAME"))
    }
    if (project.hasProperty("POM_DESCRIPTION")) {
        project.ext.set("POM_DESCRIPTION", rootProject.getProperty("POM_DESCRIPTION"))
    }

    // Only apply to modules that use the Android Library plugin
    plugins.withId('com.android.library') {
        base {
            archivesName = "${rootProject.name}-${project.name}"
        }
        
        android {
            libraryVariants.all { variant ->
                variant.outputs.all { output ->
                    if (outputFileName.endsWith('.aar')) {
                        if (variant.name == "release") {
                            outputFileName = "${rootProject.name}-${sqliteVersion}.aar"
                        } else {
                            outputFileName = "${rootProject.name}-${sqliteVersion}-${variant.name}.aar"
                        }
                    }
                }
            }
        }

        tasks.named('preBuild') {
            dependsOn ':installSqliteHeader'
            dependsOn ':configureBuild'
        }

        afterEvaluate {
            if (rootProject.ext.sqliteVersion != "") {
                tasks.named("downloadSqlite").configure { it.enabled = false }

                // register your own task
                tasks.register("downloadSqliteCustom", Download) { t ->
                    src sqliteAmalgamationUrl(rootProject.ext.sqliteVersion)
                    dest "src/main/jni/sqlite.zip"
                }
            }
        }
    }
}

ext {
    decimalDistributionUrl = "https://raw.githubusercontent.com/sqlite/sqlite/master/ext/misc/decimal.c"
    sqliteNativeSources = "sqlite-android/sqlite-android/src/main/jni/sqlite"
}

apply plugin: "de.undercouch.download"

// Apply patches before upstream compilation
tasks.register("configureBuild") {
    dependsOn ':installSqliteHeader'
    dependsOn ':sqlite-android:installSqlite'

    doLast {
        // Download decimals directly from SQLite mirror in the github
        project.download.run {
            src decimalDistributionUrl
            dest sqliteNativeSources
            overwrite false
        }

        // Copy files from files
        copy {
            from "${rootDir}/src"
            into rootProject.project(':sqlite-android').projectDir.absolutePath + "/src"
        }

        // Patch files
        file("${rootDir}/patches").listFiles()?.each { patch ->
            if (patch.isFile()) {
                def execProvider = providers.exec {
                    commandLine 'git', 'apply', '--ignore-space-change', '--check', '--reverse', patch.absolutePath
                    ignoreExitValue = true
                }
                // Access the results lazily
                def execResult = execProvider.result.get()
                if (execResult.exitValue != 0) {
                    execProvider = providers.exec {
                        commandLine 'git', 'apply', '--ignore-space-change', "--verbose", patch.absolutePath
                    }
                    if (execProvider.result.get().exitValue == 0) {
                        logger.lifecycle("Patch '${patch.name}' has been applied successfully.")
                    } else {
                        logger.lifecycle("Failed to apply patch: ${patch.name} with exit code ${execProvider.result.get().exitValue}\n${execProvider.standardError.asText.get()}")
                        throw new GradleException("Failed to apply patch: ${patch.name}")
                    }
                } else {
                    logger.lifecycle("Patch '${patch.name}' already applied.")
                }
            }
        }
    }
}

tasks.register("installSqliteHeader") {
    dependsOn ':sqlite-android:downloadSqlite'
    def downloadTask = project(":sqlite-android").tasks.named("downloadSqlite")
    inputs.file(downloadTask.map { it.dest })

    doFirst {
        copy {
            // Use zipTree on the 'dest' file from the download task
            from zipTree(downloadTask.get().dest)
            into sqliteNativeSources
            // Filter for the specific file
            include "**/sqlite3ext.h"
            // Flatten the structure so it's not nested in zip folders
            eachFile { it.path = it.name }
        }
    }
}

tasks.register("exportVars") {
    dependsOn "Prebuild"
    doLast {
        def outputFile = System.getenv("GITHUB_OUTPUT")
        if (outputFile != null) {
            new File(outputFile) << "VERSION_NAME=${VERSION_NAME}\n"
            new File(outputFile) << "PUBLISH_TYPE=${publishType == 0? "Snapshot": "Release"}\n"
            new File(outputFile) << "SQLITE_VERSION=${rootProject.ext.sqliteVersion}\n"
        }
    }
}

tasks.register("regeneratePatches") {
    group = "maintenance"
    description = "Generate patches"

    doLast {
        file("${rootDir}/patched").listFiles()?.each { target ->
            if (!target.isDirectory()) {
                println "Generating patch for " + target.name
                def patchFile = file("${rootDir}/patches/${target.name}.patch")
                providers.exec {
                    // Command: git diff --patch --unified=5 --no-index --output=patch_file source_file target_file
                    commandLine 'git', 'diff', '--patch', '--unified=5', '--no-index', "--output=${patchFile.absolutePath}", sqliteNativeSources + "/" + target.name, target.absolutePath
                    ignoreExitValue = true
                }
                if (patchFile.exists()) {
                    if (patchFile.length() == 0) {
                        patchFile.delete()
                    } else {
                        ant.replace(
                            file:  "${rootDir}/patches/${target.name}.patch",
                            token: "b/${target.absolutePath.trim('/').replace('\\', '\\\\')}",
                            value: "b/${sqliteNativeSources + "/" + target.name}"
                        )
                        println "Patch generated for " + target.name
                    }
                }
            }
        }
    }
}