plugins {
    id 'com.android.library' version '8.13.0' apply false
    id 'com.android.application' version '8.13.0' apply false
    id 'de.undercouch.download' version '5.6.0' apply false
    id 'signing'
}

project(':sqlite-android') {
    // Force :requery-root to be ready first
    evaluationDependsOn(':requery-root')

    if (!rootProject.hasProperty("VERSION_NAME") && project(':requery-root').hasProperty("VERSION_NAME")) {
        def versionName = project(':requery-root').getProperty("VERSION_NAME")
        if (rootProject.hasProperty("VERSION_TYPE")) {
            if (rootProject.getProperty("VERSION_TYPE").equalsIgnoreCase("Release")) {
                versionName = versionName.replaceAll(/-SNAPSHOT$/, '')
            } else if (rootProject.getProperty("VERSION_TYPE").equalsIgnoreCase("Snapshot")) {
                if (!versionName.toUpperCase().endsWith('-SNAPSHOT')) {
                    versionName += '-SNAPSHOT'
                }
            } else {
                throw new GradleException("VERSION_TYPE has to be either Release or Snapshot")
            }
        }
        project.ext.set("VERSION_NAME", versionName)
    }

    if (project.hasProperty("POM_ARTIFACT_ID")) {
        project.ext.set("POM_ARTIFACT_ID", rootProject.getProperty("POM_ARTIFACT_ID"))
    }
    if (project.hasProperty("POM_NAME")) {
        project.ext.set("POM_NAME", rootProject.getProperty("POM_NAME"))
    }
    if (project.hasProperty("POM_DESCRIPTION")) {
        project.ext.set("POM_DESCRIPTION", rootProject.getProperty("POM_DESCRIPTION"))
    }

    // Only apply to modules that use the Android Library plugin
    plugins.withId('com.android.library') {
        base {
            archivesName = "${rootProject.name}-${project.name}"
        }
        
        android {
            libraryVariants.all { variant ->
                variant.outputs.all { output ->
                    if (outputFileName.endsWith('.aar')) {
                        // Custom naming logic: [ProjectName]-[Variant]-[Version].aar
                        //outputFileName = "${project.name}-${variant.name}-${project.version}.aar"
                        outputFileName = "${rootProject.name}-${variant.name}.aar"
                    }
                }
            }
        }

        tasks.named('preBuild') {
            dependsOn ':installSqliteHeader'
            dependsOn ':configureBuild'
        }
    }
}

ext {
    decimalDistributionUrl = "https://raw.githubusercontent.com/sqlite/sqlite/master/ext/misc/decimal.c"
    sqliteNativeSources = "sqlite-android/sqlite-android/src/main/jni/sqlite"
}

apply plugin: "de.undercouch.download"

// Apply patches before upstream compilation
tasks.register("configureBuild") {
    dependsOn ':installSqliteHeader'
    dependsOn ':sqlite-android:installSqlite'

    doLast {
        // Download decimals directly from SQLite mirror in the github
        project.download.run {
            src decimalDistributionUrl
            dest sqliteNativeSources
            overwrite false
        }

        // Copy files from files
        copy {
            from "${rootDir}/src"
            into rootProject.project(':sqlite-android').projectDir.absolutePath + "/src"
        }

        // Patch files
        file("${rootDir}/patches").listFiles()?.each { patch ->
            if (patch.isFile()) {
                def execProvider = providers.exec {
                    commandLine 'git', 'apply', '--ignore-space-change', '--check', '--reverse', patch.absolutePath
                    ignoreExitValue = true
                }
                // Access the results lazily
                def execResult = execProvider.result.get()
                if (execResult.exitValue != 0) {
                    execProvider = providers.exec {
                        commandLine 'git', 'apply', '--ignore-space-change', "--verbose", patch.absolutePath
                    }
                    if (execProvider.result.get().exitValue == 0) {
                        logger.lifecycle("Patch '${patch.name}' has been applied successfully.")
                    } else {
                        logger.lifecycle("Failed to apply patch: ${patch.name} with exit code ${execProvider.result.get().exitValue}\n${execProvider.standardError.asText.get()}")
                        throw new GradleException("Failed to apply patch: ${patch.name}")
                    }
                } else {
                    logger.lifecycle("Patch '${patch.name}' already applied.")
                }
            }
        }
    }
}

tasks.register("installSqliteHeader") {
    def downloadTask = project(":sqlite-android").tasks.named("downloadSqlite")
    inputs.file(downloadTask.map { it.dest })

    doFirst {
        copy {
            // Use zipTree on the 'dest' file from the download task
            from zipTree(downloadTask.get().dest)
            into "sqlite-android/sqlite-android/src/main/jni/sqlite"
            // Filter for the specific file
            include "**/sqlite3ext.h"
            // Flatten the structure so it's not nested in zip folders
            eachFile { it.path = it.name }
        }
    }
}

task regeneratePatches {
    group = "maintenance"
    description = "Generate patches"

    doLast {
        file("${rootDir}/patched").listFiles()?.each { target ->
            if (!target.isDirectory()) {
                println "Generating patch for " + target.name
                def patchFile = file("${rootDir}/patches/${target.name}.patch")
                providers.exec {
                    // Command: git diff --patch --unified=5 --no-index --output=patch_file source_file target_file
                    commandLine 'git', 'diff', '--patch', '--unified=5', '--no-index', "--output=${patchFile.absolutePath}", sqliteNativeSources + "/" + target.name, target.absolutePath
                    ignoreExitValue = true
                }
                if (patchFile.exists()) {
                    if (patchFile.length() == 0) {
                        patchFile.delete()
                    } else {
                        ant.replace(
                            file:  "${rootDir}/patches/${target.name}.patch",
                            token: "b/${target.absolutePath.trim('/').replace('\\', '\\\\')}",
                            value: "b/${sqliteNativeSources + "/" + target.name}"
                        )
                        println "Patch generated for " + target.name
                    }
                }
            }
        }
    }
}